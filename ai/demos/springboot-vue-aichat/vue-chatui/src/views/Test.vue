<template>
  <el-container class="ai-chat-container">
    <el-main>
      <el-card class="response-card">
        <markdown-renderer 
          :content="responseContent" 
          :is-typing="isTyping" 
        />
      </el-card>
    </el-main>
  </el-container>
</template>

<script>
import MarkdownRenderer from '@/components/MarkdownRenderer.vue'

export default {
  components: { MarkdownRenderer },
  data() {
    return {
      responseContent: '',
      isTyping: true,
      fullResponse: '```markdown#èƒŒæ™¯æ¸¸è®°ï¼šæŽ¢ç´¢äº‘å—çš„ç¥žç§˜ä¹‹æ—…```markdown#èƒŒæ™¯æ¸¸è®°ï¼šæŽ¢ç´¢äº‘å—çš„ç¥žç§˜ä¹‹æ—…è¯†äº‘å—æ—…è¡Œå§‹äºŽå¯¹äº‘å—çš„å¥½å¥‡ã€‚ä½œä¸ºä¸­å›½è¥¿å—çš„è¾¹é™²çœä»½ï¼Œäº‘å—ä»¥å…¶å¤šæ ·çš„æ°‘æ—```markdown#èƒŒæ™¯æ¸¸è®°ï¼šæŽ¢ç´¢äº‘å—çš„ç¥žç§˜ä¹‹æ—…è¯†äº‘å—æ—…è¡Œå§‹äºŽå¯¹äº‘å—çš„å¥½å¥‡ã€‚ä½œä¸ºä¸­å›½è¥¿å—çš„è¾¹é™²çœä»½ï¼Œäº‘å—ä»¥å…¶å¤šæ ·çš„æ°‘æ—æ–‡åŒ–å’Œå£®ä¸½çš„è‡ªç„¶é£Žå…‰é—»åã€‚## ç©¿è¶Šå¤åŸŽé¦–å…ˆæŠµè¾¾ä¸½æ±Ÿå¤åŸŽï¼Œé’çŸ³æ¿markdown#èƒŒæ™¯æ¸¸è®°ï¼šæŽ¢ç´¢äº‘å—çš„ç¥žç§˜ä¹‹æ—…è¯†äº‘å—æ—…è¡Œå§‹äºŽå¯¹äº‘å—çš„å¥½å¥‡ã€‚ä½œä¸ºä¸­å›½è¥¿å—çš„è¾¹é™²çœä»½ï¼Œäº‘å—ä»¥å…¶å¤šæ ·çš„æ°‘æ—æ–‡åŒ–å’Œå£®ä¸½çš„è‡ªç„¶é£Žå…‰é—»åã€‚## ç©¿è¶Šå¤åŸŽé¦–å…ˆæŠµè¾¾ä¸½æ±Ÿå¤åŸŽï¼Œé’çŸ³æ¿è·¯å’Œçº³è¥¿æ—å»ºç­‘è®©äººä»¿ä½›ç©¿è¶Šå›žå¤ä»£ã€‚## é«˜åŽŸä¹‹è¡Œå‰å¾€é¦™æ ¼é‡Œäº‘å—çš„ç¥žç§˜ä¹‹æ—…è¯†äº‘å—æ—…è¡Œå§‹äºŽå¯¹äº‘å—çš„å¥½å¥‡ã€‚ä½œä¸ºä¸­å›½è¥¿å—çš„è¾¹é™²çœä»½ï¼Œäº‘å—ä»¥å…¶å¤šæ ·çš„æ°‘æ—æ–‡åŒ–å’Œå£®ä¸½çš„è‡ªç„¶é£Žå…‰é—»åã€‚## ç©¿è¶Šå¤åŸŽé¦–å…ˆæŠµè¾¾ä¸½æ±Ÿå¤åŸŽï¼Œé’çŸ³æ¿è·¯å’Œçº³è¥¿æ—å»ºç­‘è®©äººä»¿ä½›ç©¿è¶Šå›žå¤ä»£ã€‚## é«˜åŽŸä¹‹è¡Œå‰å¾€é¦™æ ¼é‡Œæ‹‰ï¼Œé«˜åŽŸçš„æ¸…æ–°ç©ºæ°”å’Œè—å¼å¯ºåº™ä»¤äººå¿ƒæ—·ç¥žæ€¡ã€‚## æ°‘æ—é£Žæƒ…çš„å¥½å¥‡ã€‚ä½œä¸ºä¸­å›½è¥¿å—çš„è¾¹é™²çœä»½ï¼Œäº‘å—ä»¥å…¶å¤šæ ·çš„æ°‘æ—æ–‡åŒ–å’Œå£®ä¸½çš„è‡ªç„¶é£Žå…‰é—»åã€‚## ç©¿è¶Šå¤åŸŽé¦–å…ˆæŠµè¾¾ä¸½æ±Ÿå¤åŸŽï¼Œé’çŸ³æ¿è·¯å’Œçº³è¥¿æ—å»ºç­‘è®©äººä»¿ä½›ç©¿è¶Šå›žå¤ä»£ã€‚## é«˜åŽŸä¹‹è¡Œå‰å¾€é¦™æ ¼é‡Œæ‹‰ï¼Œé«˜åŽŸçš„æ¸…æ–°ç©ºæ°”å’Œè—å¼å¯ºåº™ä»¤äººå¿ƒæ—·ç¥žæ€¡ã€‚## æ°‘æ—é£Žæƒ…å¤§ç†ï¼Œç™½æ—çš„ä¸‰é“èŒ¶å’Œæ‰ŽæŸ“å·¥è‰ºå±•çŽ°äº†ç‹¬ç‰¹çš„æ°‘æ—æ–‡åŒ–ã€‚## å›žç¨‹æ„Ÿæ‚Ÿè‡ªç„¶é£Žå…‰é—»åã€‚## ç©¿è¶Šå¤åŸŽé¦–å…ˆæŠµè¾¾ä¸½æ±Ÿå¤åŸŽï¼Œé’çŸ³æ¿è·¯å’Œçº³è¥¿æ—å»ºç­‘è®©äººä»¿ä½›ç©¿è¶Šå›žå¤ä»£ã€‚## é«˜åŽŸä¹‹è¡Œå‰å¾€é¦™æ ¼é‡Œæ‹‰ï¼Œé«˜åŽŸçš„æ¸…æ–°ç©ºæ°”å’Œè—å¼å¯ºåº™ä»¤äººå¿ƒæ—·ç¥žæ€¡ã€‚## æ°‘æ—é£Žæƒ…å¤§ç†ï¼Œç™½æ—çš„ä¸‰é“èŒ¶å’Œæ‰ŽæŸ“å·¥è‰ºå±•çŽ°äº†ç‹¬ç‰¹çš„æ°‘æ—æ–‡åŒ–ã€‚## å›žç¨‹æ„Ÿæ‚ŸçŸ­ï¼Œå´è®©æˆ‘æ·±åˆ»æ„Ÿå—åˆ°äº‘å—çš„å¤šæ ·ä¸Žç¾Žä¸½ï¼Œç•™ä¸‹äº†éš¾å¿˜çš„å›žå¿†ã€‚',
//       fullResponse: `# AI å›žç­”ç¤ºä¾‹

// ## ä»£ç ç¤ºä¾‹
// \`\`\`javascript
// // Vue ç»„ä»¶ç¤ºä¾‹
// export default {
//   data() {
//     return {
//       message: 'Hello AI!'
//     }
//   },
//   mounted() {
//     console.log(this.message)
//   }
// }
// \`\`\`

// ## åŠŸèƒ½åˆ—è¡¨
// - âœ… Markdown æ¸²æŸ“
// - âœ¨ ä»£ç é«˜äº®
// - ðŸ’¬ æ¨¡æ‹Ÿ AI å¯¹è¯æ•ˆæžœ

// > æç¤ºï¼šè¿™æ˜¯æ¨¡æ‹Ÿçš„ AI å›žç­”å†…å®¹
// `
    }
  },
  mounted() {
    this.simulateTyping()
  },
  methods: {
    cleanStreamedMarkdown(streamedText) {
      if (!streamedText) return ''
      
      // Step 1: Remove duplicate content by keeping only the last occurrence
      let cleanText = streamedText
      
      // Step 2: Remove any markdown code block markers that might be malformed
      cleanText = cleanText.replace(/```markdown/g, '').replace(/```/g, '')
      
      // Step 3: Fix headers that might be broken across streams
      cleanText = cleanText.replace(/([^#\n]|^)(#+)([^#\s\n])/g, '$1$2 $3')
      cleanText = cleanText.replace(/(#+)\s+/g, '$1 ')
      
      // Step 4: Remove duplicate sections by finding the last complete version
      const sections = {}
      const headerRegex = /(^|\n)(#+ .+?)(?=\n#|$)/gs
      let match
      
      while ((match = headerRegex.exec(cleanText))) {
        const header = match[2]
        const contentStart = match.index + match[1].length
        const nextMatch = headerRegex.exec(cleanText)
        const contentEnd = nextMatch ? nextMatch.index : cleanText.length
        const content = cleanText.slice(contentStart + header.length, contentEnd).trim()
        
        // Keep the last version of each section
        sections[header] = content
      }
      
      // Step 5: Rebuild the markdown from the cleaned sections
      let result = ''
      for (const [header, content] of Object.entries(sections)) {
        result += `${header}\n\n${content}\n\n`
      }
      
      // Step 6: Remove any remaining duplicate lines
      const lines = result.split('\n')
      const uniqueLines = []
      const seenLines = new Set()
      
      for (const line of lines) {
        const trimmed = line.trim()
        if (!seenLines.has(trimmed)) {
          seenLines.add(trimmed)
          uniqueLines.push(line)
        }
      }
      
      return uniqueLines.join('\n').trim()
    },
    simulateTyping() {
    //   console.log("clean =>", this.cleanStreamedMarkdown(this.fullResponse))
      let index = 0
      const typingInterval = setInterval(() => {
        if (index <= this.fullResponse.length) {
          this.responseContent = this.fullResponse.substring(0, index)
          index++
        } else {
          clearInterval(typingInterval)
          this.isTyping = false
        }
      }, 20)
    }
  }
}
</script>

<style scoped>
.ai-chat-container {
  height: 100vh;
  background-color: #f0f2f5;
  padding: 20px;
}

.response-card {
  border-radius: 12px;
  transition: all 0.3s;
}

.response-card:hover {
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}
</style>